<!DOCTYPE html>
<!--
    So Simple Jekyll Theme 3.2.0
    Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
    Free for personal and commercial use under the MIT license
    https://github.com/mmistakes/so-simple-theme/blob/master/LICENSE
-->
<html lang="en-US" class="no-js">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  

  
    <title>Dfs와 Bfs</title>
    <meta name="description" content="개념">
    <link rel="canonical" href="https://10cheon00.github.io/algorithm/DFS%EC%99%80-BFS/">
  

  <script>
    /* Cut the mustard */
    if ( 'querySelector' in document && 'addEventListener' in window ) {
      document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + 'js';
    }
  </script>

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/skins/dark.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nanum+Gothic:400,700|Noto+Sans+KR:100,700|Source+Sans+Pro:400,400i,700,700i">
  <!-- start custom head snippets -->

<!-- Favicons -->
<link rel="shortcut icon" type="image/png" href="/assets/favicon-512x512.png">

<!-- Katex -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
</script>

<!-- end custom head snippets -->

</head>


  <body class="layout--post  dfs와-bfs">
    <div class="header">
      <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#primary-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

      
  <div class="navigation-wrapper">
    <div class="navigation-bar">
      <a href="/">
        <div class="fa fa-home fa-lg"></div>
      </a>
      <a href="#menu-toggle" class="menu-toggle">
        <div class="fa fa-bars fa-lg"></div>
      </a>
    </div>

    <aside id="primary-nav" class="toggle-sidebar">
      <a href="#menu-toggle" class="menu-toggle toggle-sidebar-exit">
        <div class="fa fa-times"></div>
      </a>

      <div class="page-sidebar">
  <div class="page-author h-card p-author"><img src="/assets/favicon-512x512.png" class="author-avatar u-photo" alt="Kim Taekcheon"><div class="author-info"><div class="author-name">
        <span class="p-name">Kim Taekcheon</span>
      </div><ul class="author-links"><li class="author-link">
            <a class="u-url" rel="me" href="https://github.com/10cheon00"><i class="fab fa-github fa-lg fa-lg" title=""></i></a>
          </li></ul></div>
</div>
 
  


  <div class="page-categories-header">
    
  </div>
  <div class="page-categories">
    
      
      <ul>
        
          <li>
            
            <a href="/categories/algorithm">
              Algorithm (12)
            </a>
            
        
          <li>
            
            <a href="/categories/maps">
              Maps (2)
            </a>
            
        
          <li>
            
            <a href="/categories/unity">
              Unity (1)
            </a>
            
        
      </ul>
    
  </div>
</div>


    </aside>
  </div><!-- /.navigation-wrapper -->


    </div>

    <main id="main" class="main-content" aria-label="Content">
  <article class="h-entry">
    

<div class="page-image">
  <div
    style="background-image: url(/assets/images/default_background.png)"
    class="entry-feature-image u-photo"
    alt="Dfs와 Bfs">
  </div>
  
  <div class="masthead">
  <div class="site-title animated fadeIn"><a href="/">공부한 것을 정리하자</a></div>
  <p class="site-description animated fadeIn" itemprop="description"></p>
</div><!-- /.masthead -->

</div>

    <div class="page-wrapper">
      <header class="page-header">
        <!-- empty title for making blank line. -->
        <h1 class="page-title"></h1>
      </header>

      <div class="page-sidebar">
  <div class="page-author h-card p-author"><img src="/assets/favicon-512x512.png" class="author-avatar u-photo" alt="Kim Taekcheon"><div class="author-info"><div class="author-name">
        <span class="p-name">Kim Taekcheon</span>
      </div><ul class="author-links"><li class="author-link">
            <a class="u-url" rel="me" href="https://github.com/10cheon00"><i class="fab fa-github fa-lg fa-lg" title=""></i></a>
          </li></ul></div>
</div>
 
  


  <div class="page-categories-header">
    
  </div>
  <div class="page-categories">
    
      
      <ul>
        
          <li>
            
            <a href="/categories/algorithm">
              Algorithm (12)
            </a>
            
        
          <li>
            
            <a href="/categories/maps">
              Maps (2)
            </a>
            
        
          <li>
            
            <a href="/categories/unity">
              Unity (1)
            </a>
            
        
      </ul>
    
  </div>
</div>


      <div class="page-content">
        <header class="page-header">
          <div class="page-categories">
            
  <h3 class="page-taxonomies-title">Categories</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a class="p-category" href="/categories/algorithm" title="Pages filed under Algorithm">Algorithm</a></li>
  </ul>


          </div>
          
          
          <h1 id="page-title" class="page-title p-name">Dfs와 Bfs
</h1>
          
          
            <div class="page-information">
              
                2023-03-06 18:00:00
              
              

<span class="read-time">9 min read</span>

            </div>
          
        </header>

        <div class="e-content">
          <h1 id="개념">개념</h1>

<p>DFS와 BFS는 모두 그래프를 탐색하는 방법이다.</p>

<p>DFS는 <span class="green">Depth-First Search(깊이 우선 탐색)</span>의 약자이고 BFS는 <span class="green">Breadth-First Search(너비 우선 탐색)</span>의 약자다.</p>

<p>비유를 해보자면 마인크래프트를 할 때 다이아몬드를 캐려고 지하 깊은 곳까지 내려갔다고 생각해보자.</p>

<p>DFS로 탐색을 하게 되면 무조건 직진하면서 뭐가 나올 때까지 파보는 것과 비슷하다.</p>

<p>BFS로 탐색을 하게 되면 자기 주변에 있는 것부터 전부 파보는 것과 비슷하다.</p>

<h1 id="dfs-깊이-우선-탐색">DFS (깊이 우선 탐색)</h1>

<h2 id="원리">원리</h2>

<p>DFS는 일단 다른 정점으로 이동할 수 있는 상황이라면 다른 정점들을 제쳐두고 먼저 이동한다.</p>

<p>이동한 정점에서 더이상 이동할 수 없으면 직전 정점으로 돌아간 후 다시 이동할 수 있는 정점을 찾아 탐색을 계속한다.</p>

<ol>
  <li>현재 정점에서 이동할 수 있는 정점을 골라 탐색한다.</li>
  <li>도착한 정점에서 이동할 수 있는 정점이 없다면 직전 정점으로 돌아간다.</li>
</ol>

<p><img src="/assets/images/algorithm/dfs_1.png" alt="dfs_1" /></p>

<p>위와 같은 그래프가 있다고 하고 1번 정점부터 DFS로 탐색을 한다고 하자.</p>

<p>먼저 이동할 수 있는 정점, <span class="orange"><strong>즉 현재 정점에 연결되어있고 아직 탐색을 하지 않은 정점들</strong></span> 중에서 하나를 골라 탐색한다.</p>

<p>1번 정점와 연결된 다른 정점은 2와 4다. 2를 골라 탐색을 한다. 이 때 노드를 고르는 정해진 순서는 딱히 없다.</p>

<p><img src="/assets/images/algorithm/dfs_2.png" alt="dfs_2" /></p>

<p>탐색을 하고 난 다음에는 현재 정점에서 이동할 수 있는 정점이 있는지 확인한다.</p>

<p>현재 2번 정점에는 1번과 3번 정점이 연결되어 있다. 하지만 1번 정점은 이미 탐색을 한 정점이므로 제외, 그러므로 3번 정점으로 이동가능하다.</p>

<p><img src="/assets/images/algorithm/dfs_3.png" alt="dfs_3" /></p>

<p>탐색 후에는 항상 이동 가능한 정점이 있는지 확인하고, 가능한 정점이 있다면 바로 이동해 탐색을 한다고 했다.</p>

<p>3번 정점에서 이동 가능한 정점은 4번 정점이다.</p>

<p><img src="/assets/images/algorithm/dfs_4.png" alt="dfs_4" /></p>

<p>이동한 4번 정점에는 5, 6, 7번 정점이 연결되어있다. 편하게 5번을 선택해 탐색한다.</p>

<p><img src="/assets/images/algorithm/dfs_5.png" alt="dfs_5" /></p>

<p>5번 정점에서는 7번 정점이 이동 가능한 정점이고,</p>

<p><img src="/assets/images/algorithm/dfs_6.png" alt="dfs_6" /></p>

<p>7번 정점에서는 8번 정점이 이동 가능한 정점이다.</p>

<p><img src="/assets/images/algorithm/dfs_7.png" alt="dfs_7" /></p>

<p>8번 정점까지 가서야 이동 가능한 정점이 없으므로 직전 정점으로 다시 거슬러 올라간다.</p>

<p><img src="/assets/images/algorithm/dfs_8.png" alt="dfs_8" /></p>

<p>7번 정점으로 거슬러 올라갔더니 이동 가능한 정점이 없다. 다시 5번 정점으로 되돌아 갔는데도 이동 가능한 정점이 없다.</p>

<p>4번 정점까지 가서야 이동 가능한 정점이 남아있다. 6번 정점으로 이동해 탐색을 계속한다.</p>

<p><img src="/assets/images/algorithm/dfs_9.png" alt="dfs_9" /></p>

<p>6번 정점으로 이동해 탐색을 하고나니 이동 가능한 정점이 없다. 다시 4번 정점으로 갔는데도 없다.</p>

<p>3번, 2번 정점에서도, 시작 지점이었던 1번 정점까지 돌아왔는데도 없으므로 탐색을 종료한다. 이게 DFS다.</p>

<h2 id="구현">구현</h2>

<p>이동 가능한 정점을 찾아 탐색하고 그런 정점이 없으면 해당 정점에서 탐색을 종료하고 직전 정점으로 돌아간다.</p>

<p>위 문장을 재귀적으로 반복하기 때문에 재귀식으로 짤 수 있다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 인접행렬을 썼을 때 </span>
<span class="kt">int</span> <span class="n">graph</span><span class="p">[</span><span class="n">SIZE</span><span class="p">][</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isVisited</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>

<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
  <span class="n">isVisited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">isVisited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">){</span> 
      <span class="n">printf</span><span class="p">(</span><span class="s">"Visited %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
      <span class="c1">// j번째 정점과 연결되어 있고 방문하지 않은 정점이라면 탐색하러 이동</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>조금 비효율적이지만 인접행렬을 써서 짜보았다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 연결리스트를 썼을 때</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isVisited</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>

<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
  <span class="n">isVisited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">iter</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isVisited</span><span class="p">[</span><span class="o">*</span><span class="n">iter</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Visited %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
      <span class="n">dfs</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>현재 정점을 탐색했다고 표시한 후, 해당 정점에 연결된 다른 정점이 있다면 그 정점으로 이동한다.</p>

<p>하지만 그래프가 매우 클 때 위 코드는 재귀식이기 때문에 스택 프레임이 터질 우려가 있다.</p>

<p>따라서 스택 프레임을 이용하지 않고 직접 스택을 구현하여 이용하면 그런 염려를 없앨 수 있다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isVisited</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">stack</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
  <span class="c1">// 먼저 시작 정점을 스택에 삽입.</span>
  <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">stackSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="c1">// push</span>
  <span class="n">isVisited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="n">stackSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// 스택에서 제일 위에 있는 정점을 꺼내어 DFS 시도.</span>
    <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">stackSize</span><span class="o">--</span><span class="p">];</span> <span class="c1">// pop</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Visited : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

    <span class="n">isVisited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">current</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">){</span>
      <span class="c1">// 현재 정점에 연결된 정점이 방문하지 않은 정점이면 스택에 추가.</span>
      <span class="k">if</span><span class="p">(</span><span class="n">isVisited</span><span class="p">[</span><span class="o">*</span><span class="n">iter</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">){</span>
        <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">stackSize</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span> <span class="c1">// push</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>스택 배열에서 0번째 원소는 편의상 쓰지 않는다.</p>

<p>보통 재귀식으로 짜는 경우가 많지만 몇몇 경우 스택 오버플로우가 터질 수 있어서 직접 스택 배열을 만들어 탐색하는 것을 선호한다.</p>

<h1 id="bfs-너비-우선-탐색">BFS (너비 우선 탐색)</h1>

<h2 id="원리-1">원리</h2>

<p>DFS와 다르게 현재 정점에 연결된 모든 정점을 탐색해보고 이동한다는 점이 다르다.</p>

<p>왜 ‘너비’ 우선 탐색이라고 부르는지 모르겠지만 주변에 있는 정점을 모두 탐색한다는 점에서 넓게 탐색한다는 의미같다.</p>

<ol>
  <li><span class="orange"><strong>큐</strong></span>에 들어있는 정점을 꺼내와 현재 정점으로 갱신한다.</li>
  <li>현재 정점과 연결된 다른 정점을 모두 <span class="orange"><strong>큐</strong></span>에 추가한다.</li>
  <li>현재 정점과 연결된 다른 정점을 모두 추가했다면 <span class="orange"><strong>큐</strong></span>에서 정점 하나를 꺼내와 다시 탐색을 진행한다.</li>
</ol>

<p><span class="orange"><strong>큐</strong></span>가 등장했기 때문에 글로는 설명이 부족하다.</p>

<p><img src="/assets/images/algorithm/bfs_1.png" alt="bfs_1" /></p>

<p>똑같은 그래프를 들고 왔다. 특이하게도 <span class="orange"><strong>큐</strong></span>를 활용해야한다.</p>

<p>먼저 시작 정점인 1번 정점을 <span class="orange"><strong>큐</strong></span>에 등록한다.</p>

<p><img src="/assets/images/algorithm/bfs_2.png" alt="bfs_2" /></p>

<p><span class="orange"><strong>큐</strong></span>에 들어있는 정점을 꺼내와 탐색한다. 1번 정점에 연결된 다른 정점을 <span class="orange"><strong>큐</strong></span>에 추가한다.</p>

<p>이 때 1번 정점과 연결된 정점을 큐에 추가했다는 말은 <span class="orange">곧 방문할 정점</span>이라는 말이다.</p>

<p>곧 방문할 것이므로 다른 정점에서 갈 필요가 없으니 <span class="green">미리 방문했다고 표시해 예외처리를 한다</span>.</p>

<p><img src="/assets/images/algorithm/bfs_3.png" alt="bfs_3" /></p>

<p>1번 정점에 연결된 모든 정점을 <span class="orange"><strong>큐</strong></span>에 추가했으므로 큐에서 하나를 꺼내와 현재 정점으로 갱신한다.</p>

<p>현재 정점은 2번 정점으로 갱신되어있다. 2번 정점과 연결된 모든 정점을 <span class="orange"><strong>큐</strong></span>에 추가한다.</p>

<p>3번 정점밖에 선택지가 없다. 1번 정점은 이미 방문한 정점이다. 3번 정점을 큐에 추가하고 방문했다고 표시한다.</p>

<p><img src="/assets/images/algorithm/bfs_4.png" alt="bfs_4" /></p>

<p>큐에서 정점을 꺼내왔더니 4번 정점이다. 현재 정점인 4번 정점과 연결된 모든 정점을 큐에 추가한다.</p>

<p>4번 정점에 연결된 정점들은 3, 5, 7, 6번 정점이지만 3번 정점은 2번 정점을 방문할 때 이미 큐에 추가했었다.</p>

<p>그러므로 이미 방문했다고 표시가 되어있으니 건너 뛴다.</p>

<p><img src="/assets/images/algorithm/bfs_5.png" alt="bfs_5" /></p>

<p>큐에서 정점을 꺼내면 3번 정점이다. 3번 정점과 연결된 정점이 없으므로 (2번 정점은 이미 방문한 정점이므로) 다시 큐에서 정점을 꺼내온다.</p>

<p><img src="/assets/images/algorithm/bfs_6.png" alt="bfs_6" /></p>

<p>큐에서 정점을 꺼냈더니 이번엔 5번 정점이다. 5번 정점도 주변에 방문하지 않은 정점이 없다. 건너 뛴다.</p>

<p><img src="/assets/images/algorithm/bfs_7.png" alt="bfs_7" /></p>

<p>이번엔 7번 정점인데, 7번 정점은 8번 정점을 방문할 수 있다. 큐에 8번 정점을 추가한다.</p>

<p><img src="/assets/images/algorithm/bfs_8.png" alt="bfs_8" /></p>

<p>6번 정점도 방문할 정점이 없으니 건너 뛴다.</p>

<p><img src="/assets/images/algorithm/bfs_9.png" alt="bfs_9" /></p>

<p>마지막으로 8번 정점을 꺼내서 탐색을 진행하면 큐가 비어버리게 된다. 큐가 비었으니 탐색을 종료한다.</p>

<h2 id="구현-1">구현</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isVisited</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">queue</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
  <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="c1">// push</span>
  <span class="n">isVisited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="n">front</span> <span class="o">-</span> <span class="n">rear</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span> <span class="c1">// 큐가 빌 때까지 반복.</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="o">++</span><span class="n">front</span><span class="p">];</span> <span class="c1">// pop</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">isVisited</span><span class="p">[</span><span class="o">*</span><span class="n">iter</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">){</span>
        <span class="c1">// 연결된 정점이 방문하지 않은 정점이면 큐에 추가.</span>
        <span class="c1">// 큐에 추가함과 동시에 방문함으로 표시해 예외처리.</span>
        <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span> <span class="c1">// push</span>
        <span class="n">isVisited</span><span class="p">[</span><span class="o">*</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><span class="orange"><strong>큐</strong></span>를 쓰기 때문에, 구현 방법이 두 가지인 DFS와 다르게 한 가지 방법밖에 없다.</p>

        </div>

        
        
          <!-- Giscus -->
<div class="giscus">
  <script src="https://giscus.app/client.js"
    data-repo="10cheon00/10cheon00.github.io"
    data-repo-id="R_kgDOI3IXyw"
    data-category="General"
    data-category-id="DIC_kwDOI3IXy84CVE30"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="dark"
    data-lang="ko"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
</div>
        
        <nav class="page-pagination" role="navigation">
  
    <a class="page-previous" href="/algorithm/%EA%B7%B8%EB%9E%98%ED%94%84/">
      <h4 class="page-pagination-label">Previous</h4>
      <span class="page-pagination-title">
        <i class="fas fa-arrow-left"></i> 그래프

      </span>
    </a>
  

  
    <a class="page-next" href="/algorithm/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC(%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)/">
      <h4 class="page-pagination-label">Next</h4>
      <span class="page-pagination-title">
        최소 신장 트리(크루스칼 알고리즘)
 <i class="fas fa-arrow-right"></i>
      </span>
    </a>
  
</nav>

      </div>
    </div>
  </article>
</main>


    <footer id="footer" class="site-footer">
  <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
<div class="social-icons"><a class="social-icon" href="/atom.xml"><i class="fas fa-rss-square fa-2x" title="Feed"></i></a></div><div class="copyright">
    
      <p>&copy; 2023 공부한 것을 정리하자. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://github.com/mmistakes/so-simple-theme" rel="nofollow">So Simple</a>.</p>
    
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>


  </body>

</html>
