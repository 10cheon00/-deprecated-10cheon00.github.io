var store = [{
        "title": "Champion",
        "excerpt":"Champion, You have been challenged by challenger. Will you accept? Map File (2) Champion 0.71.zip Information Category   Version 0.71 Players 2 Type Ground Tileset Badland Resources Base Resource Main 9M + 1G Frontyard 7M + 1G Mineral only 6M 1/7 nat 7M + 1G 3/9 nat 8M + 1G...","categories": ["Maps"],
        "tags": [],
        "url": "https://10cheon00.github.io/maps/Champion/"
      },{
        "title": "Rudeltaktik",
        "excerpt":"“The only thing that ever really frightened me during the war was the U-boat peril.” The Second World War, Volume 2, published in 1949, Winston Churchill Map File Download Information Category   Version 0.2 Players 4 Type Hybrid island Tileset Twilight Resources Base Resource Main 9M + 1G + 1G...","categories": ["Maps"],
        "tags": [],
        "url": "https://10cheon00.github.io/maps/Rudeltaktik/"
      },{
        "title": "비트연산자",
        "excerpt":"C++ built-in operators, precedence, and associativity Learn more about: C++ built-in operators, precedence, and associativity https://learn.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170 알고리즘을 공부하면서 알게된 내용을 적어보았다. 알아두면 좋았을 것들 &gt;&gt;= 오른쪽으로 시프트 후 대입 &lt;&lt;= 오른쪽으로 시프트 후 대입 비트연산자는 변수에 바로 영향을 주는게 아닌 연산만 한다. 대입연산을 활용하면 i = i &gt;&gt; 2를 i...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EB%B9%84%ED%8A%B8%EC%97%B0%EC%82%B0%EC%9E%90/"
      },{
        "title": "링크드리스트",
        "excerpt":"시간복잡도 삽입 : O(1)O(1)O(1) 삭제 : O(1)O(1)O(1) 탐색 : O(N)O(N)O(N)장점 값을 저장할 때 연속적인 공간에 저장하지 않음으로 배열보다 자유롭게 메모리를 관리할 수 있다. 한 번 선언하면 크기를 바꾸기 힘든 배열과 다르게 크기에 대한 제한이 없다.단점 연속적인 공간에 저장하지 않기 때문에 인덱스를 활용한 Direct Access는 불가능하다. 정적 크기를 갖는 배열과 다르게...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/"
      },{
        "title": "단방향 링크드리스트",
        "excerpt":"링크드리스트 개념 코드는 제 마음대로 작성했기 때문에 보편적인 방법이 아닐 수 있습니다.구현 struct Node{ int value; Node* next;};링크드리스트는 배열처럼 직접 접근이 불가능하기 때문에 항상 시작점 또는 끝점을 알고 있어야 한다. 단방향 링크드리스트는 다음 노드를 가리키는 관계만 있기 때문에, 끝점을 알아도 활용이 어려우므로 시작점만 변수로 갖는다. 삽입 링크드리스트는 인덱스를 활용한 직접...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/"
      },{
        "title": "양방향 링크드리스트",
        "excerpt":"링크드리스트 개념 코드는 제 마음대로 작성했기 때문에 보편적인 방법이 아닐 수 있습니다.구현 struct Node{ int value; Node* prev, * next;};Node* head, * tail;단방향 링크드리스트와 다르게 직전 노드를 참조하는 prev변수를 갖고 있다. 따라서 시작점뿐만 아니라 끝점에서도 역순으로 순회가 가능하므로 시작점과 끝점을 나타내는 변수를 모두 갖고 있어야 한다. 초기화 Node* head =...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EC%96%91%EB%B0%A9%ED%96%A5-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/"
      },{
        "title": "트리",
        "excerpt":"개념 트리는 값을 갖는 노드들로 구성된 자료구조를 말한다. 트리는 그래프처럼 생겼지만 순환성이 없는 그래프다. 최상위 루트 노드로부터 뻗어져나가는 모습을 보면 나무 모양이 보이기 때문에 트리라고 부른다. 구성요소 위 사진을 참고하면 트리 안에는 여러가지 구성요소를 나타내는 용어들이 있다. 루트 노드 : 트리의 최상위 노드 간선 : 부모 노드와 자식 노드를 연결...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%ED%8A%B8%EB%A6%AC/"
      },{
        "title": "이진 트리",
        "excerpt":"코드는 제 마음대로 작성했기 때문에 보편적인 방법이 아닐 수 있습니다.개념 이진 트리란 일반적으로 자식 노드를 최대 2개까지 갖는 자료구조다. 자식 노드가 최대 2개니까 탐색하기 매우 쉽다. 완전 이진 트리 완전 이진 트리란 마지막 레벨을 제외하고 모든 레벨이 완전히 차있으며 마지막 레벨에서도 노드들이 왼쪽으로 모여있는 형태를 말한다. 마지막 레벨인 2레벨을 보면...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC/"
      },{
        "title": "최소 공통 조상",
        "excerpt":"LCA(최소 공통 조상) 이진 트리에서 두 노드가 가장 처음으로 갖는 공통 조상 노드를 찾는 알고리즘이다. 위 사진에서 화살표로 표시한 노드의 최소 공통 조상은 파란색으로 표시된 노드다. 원리 간단한 방법은 다음과 같다. 두 노드의 깊이(depth)를 동일하게 만든다. 깊이를 맞춘 두 노드로부터 한 칸 씩 상위로 이동했을 때 두 노드가 같은 노드인지(공통...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EC%B5%9C%EC%86%8C-%EA%B3%B5%ED%86%B5-%EC%A1%B0%EC%83%81/"
      },{
        "title": "우선순위 큐",
        "excerpt":"개념 완전 이진 트리를 기반으로 하는 자료구조다. 주어진 값들 중 최대 또는 최소를 찾아내는 속도가 매우 빠르다. 시간복잡도 삽입 : O(logN)O(logN)O(logN) 삭제 : O(logN)O(logN)O(logN) 탐색 : O(1)O(1)O(1)원리 우선순위 큐는 힙을 이용한다. 힙은 완전 이진 트리를 기반으로 만들어진 자료구조다. 힙 힙은 주어진 값들 중 최대 또는 최소를 O(logN)O(logN)O(logN)만에 찾아낼 수 있는...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90/"
      },{
        "title": "그래프",
        "excerpt":"개념 그래프는 정점과 간선으로 구성된 자료구조다. 정점 사이의 다대다 관계를 나타낸다. 종류 방향 그래프 그래프의 간선에 방향이 있다. 1번 정점은 3번 정점으로 가는 간선이 있지만 3번 정점은 1번 정점으로 가는 간선이 없다. 무방향 그래프 그래프의 간선에 방향이 없다. 각 정점은 서로 연결된 정점으로 가는 간선을 갖고 있다. 가중치 그래프 그래프의...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EA%B7%B8%EB%9E%98%ED%94%84/"
      },{
        "title": "Dfs와 Bfs",
        "excerpt":"개념 DFS와 BFS는 모두 그래프를 탐색하는 방법이다. DFS는 Depth-First Search(깊이 우선 탐색)의 약자이고 BFS는 Breadth-First Search(너비 우선 탐색)의 약자다. 비유를 해보자면 마인크래프트를 할 때 다이아몬드를 캐려고 지하 깊은 곳까지 내려갔다고 생각해보자. DFS로 탐색을 하게 되면 무조건 직진하면서 뭐가 나올 때까지 파보는 것과 비슷하다. BFS로 탐색을 하게 되면 자기 주변에 있는...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/DFS%EC%99%80-BFS/"
      },{
        "title": "최소 신장 트리(크루스칼 알고리즘)",
        "excerpt":"최소 신장 트리 (크루스칼 알고리즘) 그래프 내에 있는 모든 정점들을 가장 적은 비용으로 연결을 해야할 때 쓰는 알고리즘이다. 시간복잡도 간선의 개수 = EEE 서로소 집합을 찾는 데 걸리는 시간 ≈ O(1)O(1)O(1) 모든 간선을 정렬 후 탐색하므로 좋은 정렬 알고리즘을 사용하면 O(ElogE)O(ElogE)O(ElogE) 따라서 시간복잡도는 O(1)+O(ElogE)=O(ElogE)O(1) + O(ElogE) = O(ElogE)O(1)+O(ElogE)=O(ElogE)이다. 원리 먼저...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC(%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)/"
      },{
        "title": "다익스트라",
        "excerpt":"다익스트라 한 정점을 기준으로 모든 정점에 대한 최소 비용을 구하는 알고리즘이다. 특정 정점에서 다른 정점으로 향할 때 걸리는 비용을 최소로 할 때 유용하다. 매 탐색마다 최소 비용을 찾아 움직이는 탐욕알고리즘이다. 단, 비용이 음수인 간선이 있다면 이 알고리즘은 사용할 수 없다. 최소 비용을 갱신할 때 최소힙에서 제일 비용이 적은 정점을 꺼내...","categories": ["Algorithm"],
        "tags": [],
        "url": "https://10cheon00.github.io/algorithm/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"
      },{
        "title": "Input Manager",
        "excerpt":"입력 관리자 - Unity 매뉴얼 Input Manager 창에서 프로젝트에 대한 입력 축 및 축과 관련된 행동을 정의할 수 있습니다. 액세스하려면 Unity의 메인 메뉴에서 Edit &gt; Project Settings로 이동한 후 오른쪽 내비게이션에서 Input Manager를 선택합니다. https://docs.unity3d.com/kr/2021.3/Manual/class-InputManager.html Input Manager 유니티에서 입력을 담당하는 매니저다. 새로운 입력 축을 생성하려면 Input Manager를 이용하면 된다. 입력의...","categories": ["Unity"],
        "tags": [],
        "url": "https://10cheon00.github.io/unity/Input-Manager/"
      }]
