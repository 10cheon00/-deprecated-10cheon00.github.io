---
layout: post
categories: Algorithm
published_at: Fri Mar 03 2023 19:51:42 GMT+0900
---

# 개념
 
완전 이진 트리를 기반으로 하는 자료구조다. 주어진 값들 중 최대 또는 최소를 찾아내는 속도가 매우 빠르다.

# 시간복잡도

- 삽입 : $$ O(logN) $$
- 삭제 : $$ O(logN) $$
- 탐색 : $$ O(1) $$

# 원리

우선순위 큐는 **힙**을 이용한다. 힙은 **<span class="green">완전 이진 트리를 기반으로 만들어진 자료구조</span>**다.

## 힙

힙은 주어진 값들 중 최대 또는 최소를 $$ O(logN) $$만에 찾아낼 수 있는 자료구조다. 

주어진 값들 중 최대값을 찾아내려고 할 때 힙은 아래 그림처럼 형성된다.

![heap_1.png](/assets/images/algorithm/heap_1.png)

이 때 힙은 <span class="orange">**부모 노드가 자식 노드보다 항상 큰 값을 갖는다는 규칙**</span>을 유지해야한다.

여기서 최대값은 15이고 힙은 항상 루트 노드만 탐색하기 때문에 항상 최대값을 얻을 수 있다.

## 삽입

완전 이진 트리로 구성되어 있기 때문에 **<span class="green">항상 트리의 마지막 레벨을 채우게 된다</span>**.

위 그림에서 19가 삽입되면 아래 그림처럼 트리의 마지막 레벨에 값이 들어간다.

![heap_2.png](/assets/images/algorithm/heap_2.png)

이 힙은 최대 힙이기 때문에 부모 노드가 자식 노드보다 값이 커야 한다. 현재 상태는 19가 11보다 크다.

즉, 삽입을 했더니 <span class="red">**자식 노드가 부모 노드보다 커서 규칙이 깨져있다**</span>. 

규칙을 만족시키기 위해 부모 노드와 자식 노드를 교환한다.

![heap_3.png](/assets/images/algorithm/heap_3.png)

교환을 했음에도 아직 부모 노드보다 자식 노드가 큰 상황이다. 따라서 규칙을 만족할 때까지 삽입한 노드를 계속 부모 노드와 교환한다.

![heap_4.png](/assets/images/algorithm/heap_4.png)

루트 노드를 만날 때까지 계속 반복하면 이렇게 트리가 변한다.

정리하면, <span class="green">**최대힙일 때 부모 노드가 새로 삽입한 노드보다 클 때까지 부모 노드와 삽입한 노드를 바꾼다**</span>.

최소힙일 경우 위 방법의 부등호를 반대로 생각하여 부모 노드가 새로 삽입한 노드보다 작을 때까지 서로 바꾼다.

## 삭제

힙에서 삭제를 한다는 말은 **<span class="orange">루트 노드를 pop하겠다</span>**는 말과 같다. 

루트 노드의 자리가 비어버렸으니 다른 노드가 그 자리를 선점해야한다. 이 때 부모 노드가 자식 노드보다 크다는 규칙을 유지해야한다.

먼저 루트 노드인 19를 삭제한다. 그리고 트리의 마지막 레벨에서 제일 오른쪽 노드를 첫번째 자리로 갖고 온다.

![heap_5.png](/assets/images/algorithm/heap_5.png)

그러면 이렇게 19가 사라지고 마지막 노드인 11이 그 자리를 메꾸게 되는데 최대힙의 규칙을 만족하지 못하고 있다.

따라서 11과 11의 자식 노드를 서로 바꾸어야 규칙을 유지시킬 수 있다.

위 그림에서 9 또는 15가 11과 자리를 바꾸어야 하는데, 9가 올 경우 규칙을 만족하지 못하므로 15를 선택해 바꾼다.

![heap_6.png](/assets/images/algorithm/heap_6.png)

이렇게 교체하고 나면 규칙을 만족한다. 만약 교체를 했음에도 규칙을 만족시키지 못하면 마지막 레벨까지 현재 노드와 하위 노드를 계속 교환한다.

정리하면 <span class="green">**트리의 마지막 노드를 루트 노드로 변경한다**</span>. 규칙을 만족시킬 때까지 <span class="green">**그 노드와 그 노드의 하위 노드중 제일 큰 값을 교환한다**</span>.

# 구현

```cpp
// 최대 힙
// 인덱스 계산을 편리하게 하기 위해 
// 배열의 0번 자리는 쓰지 않고 1번부터 쓴다.
int heap[MAX_NODE + 1];
int size;
```

힙은 완전 이진 트리이기 때문에 구조체를 사용하지 않고 배열만 사용해도 남는 공간이 없이 알뜰하게 구현할 수 있다.

인덱스 계산을 편리하게 하기 위해 0번째 값을 1번 노드로 쓰지 않고 1번째 값을 1번 노드로 한다. 

이렇게 안하면 조금 계산이 복잡해지기 때문에 직관적인 편의를 위해 0번째 값을 쓰지 않는다.

## 삽입 

```cpp
void insert(int value){
  heap[++size] = value;
  for(int i = size; i > 1; i /= 2){
    // 현재 노드 = heap[i]
    // 현재 노드의 부모 노드 = heap[i/2]
    // 이런 인덱스 계산이 가능한 이유는 완전 이진 트리이기 때문이다.
    if(heap[i] > heap[i/2]){
      int t = heap[i];
      heap[i] = heap[i/2];
      heap[i/2] = t;
    }
    else{
      break;
    }
  }
}
```

앞서 설명했듯이 삽입한 노드의 부모 노드를 계속 확인하며 교환한다. 

부모를 조회하는 방법은 단순히 현재 노드의 인덱스를 2로 나눈 건데 이유는 아래 그림에 있다.

![heap_7.png](/assets/images/algorithm/heap_7.png)

완전 이진 트리에서 노드의 인덱스를 나타내면 이렇게 되는데 <span class="orange">i가 7일 경우 i번째 노드의 부모는 단순히 2로 나눈 값</span>이기 때문이다.

반대로 생각하면 부모 노드의 인덱스에 2를 곱하면 왼쪽 자식 노드, 그 값에 1을 더하면 오른쪽 자식 노드다. 이 원리는 삭제 과정에서도 활용한다.

자식 노드가 부모 노드보다 크다면 교환을 하고 그렇지 않으면 바로 종료한다. 

## 삭제

```cpp
int pop(){
  int top = heap[1];
  heap[1] = heap[size--];

  for(int i=1; i*2 <= size;){
    if(i*2 == size || heap[i*2] > heap[i*2+1]){
      // 현재 노드의 자식이 왼쪽밖에 없거나 왼쪽이 오른쪽보다 더 클 경우
      // 왼쪽 자식 노드와 현재 노드를 바꿀지 판단한다.
      if(heap[i] < heap[i*2]){
        // 만약 왼쪽 자식 노드가 현재 노드보다 크다면
        // 왼쪽 자식 노드를 현재 노드와 교체한다.
        int t = heap[i];
        heap[i] = heap[i*2];
        heap[i*2] = t
      }
      else{
        // 그렇지 않으면 부모 노드가 자식 노드보다 크다는 말이므로 종료.
        break;
      }
    }
    else{
      // 오른쪽 노드가 왼쪽 노드보다 더 큰 경우
      // 오른쪽 자식 노드를 현재 노드와 바꿀지 판단한다.
      if(heap[i] < heap[i*2+1]){
        int t = heap[i];
        heap[i] = heap[i*2+1];
        heap[i*2+1] = t;
      }
      else{
        // 그렇지 않으면 부모 노드가 자식 노드보다 크다는 말이므로 종료.
        break;
      }
    }
  }
  return top;
}
```

앞에서 언급했듯이 현재 노드의 인덱스가 i면 <span class="orange">$$ i \times 2 $$번째 노드는 왼쪽 자식 노드, $$ i \times 2 + 1$$은 오른쪽 자식 노드다</span>.

왼쪽 노드를 교체할지 말지 고민해야할 상황은,

1. 현재 노드의 자식이 왼쪽 노드밖에 없다.
2. 왼쪽 노드가 오른쪽 노드보다 크다.

이 두 가지 뿐이다.

먼저 `i*2 == size`를 통해 왼쪽 노드밖에 없는 상황을 처리했다. 

만약 `i*2 != size`라면 오른쪽 노드도 있다는 말이므로 `heap[i*2] > heap[i*2+1]`로 오른쪽 노드와 왼쪽 노드를 비교한다.

선택한 하위 노드가 부모 노드보다 크다면 두 노드를 교체한다. 

그렇지 않으면 규칙을 이미 만족하고 있다는 말이므로 그대로 종료한다.

# 정리

위 과정을 배열로 나타내어 보면 **첫 번째 값을 참조하거나 삭제**하고, **마지막에 삽입**을 하기 때문에 큐 형태를 띈다하여 **<span class="green">우선순위 큐</span>**라고 부른다.

데이터의 양이 많지만 전체를 순회하지 않고 최대값 또는 최소값만 연속적으로 빠르게 찾아야 하는 상황에서 쓰면 좋다.