---
layout: post
categories: Algorithm
published_at: Wed Mar 22 2023 14:55:25 GMT+0900
---

# 다익스트라

한 정점을 기준으로 모든 정점에 대한 최소 비용을 구하는 알고리즘이다.

특정 정점에서 다른 정점으로 향할 때 걸리는 비용을 최소로 할 때 유용하다.

매 탐색마다 최소 비용을 찾아 움직이는 탐욕알고리즘이다.

<span class="red">단, 비용이 음수인 간선이 있다면 이 알고리즘은 사용할 수 없다</span>.

최소 비용을 갱신할 때 최소힙에서 제일 비용이 적은 정점을 꺼내 확인하기 때문에 비용이 음수인 간선이 있다면 제대로된 결과를 얻을 수 없다.

## 시간복잡도

정점의 개수 = $$ V $$, 간선의 개수 = $$ E $$

각 정점이 정확히 한 번씩 방문되고, 그에 따라 간선도 한 번씩 검사되므로,<br/>
모든 간선을 탐색하는 데에 걸리는 시간 = $$ O(E) $$

최악의 경우 간선을 검사할 때마다 값이 갱신되어 최소힙에 삽입하게 된다.<br/>
이 때 걸리는 시간은 $$ O(E \times logE) $$

그러므로 시간복잡도는 $$ O(E) + O(ElogE) = O(ElogE) $$

대부분의 경우 그래프의 $$ V^2 $$가 $$ E $$보다 작으므로 (완전그래프가 아니라는 말),<br/>
$$ O(ElogE) $$를 $$ O(ElogV) $$로 나타낼 수 있다.

# 원리

### 전처리

- 시작 정점에서 도착 정점까지 향할 때 최소 비용을 담는 배열을 만든다. <br/>
배열의 원소들은 무한으로 초기화한다. <br/>
시작 정점의 값은 0으로 한다.
- 정점과, 그 정점으로 향할 때 드는 비용을 담는 최소힙을 만든다. <br/>
시작 정점과 비용 0을 최소힙에 추가한다. 

1. 최소힙에서 가장 비용이 적은 정점을 꺼내온다.
2. 그 정점을 시작으로 하는 모든 간선에 대해 <span class="orange">그 정점까지의 비용과 간선의 비용을 더한 값이 도착 정점까지의 비용보다 작다면</span> 도착 정점까지 향할 때 드는 비용을 갱신한다.
3. 만약 도착 정점의 비용을 갱신했다면 도착 정점을 최소힙에 추가한다.

# 설명

먼저 아래와 같은 그래프를 예시로 삼고, 최소 비용을 담는 배열을 만든다.

최소 비용은 전부 무한으로 초기화한 후 시작 정점인 1번만 0으로 만든다.

최소힙에 <1번, 0>을 넣어 초기화한다.

![dijkstra_1.png](/assets/images/algorithm/dijkstra_1.png)

먼저 최소힙에서 정점과 비용을 꺼내온다. 초기화할 때 넣었던 <1번, 0>이 나온다.

1번 정점에 연결된 다른 간선들에 대해서, **<span class="orange">1번 정점의 비용 + 간선의 비용</span>이 <span class="orange">도착 정점의 비용보다 작다면</span>**,<br/>
최소 비용 배열의 값을 갱신하고 <도착 정점, 도착 정점의 갱신된 비용>을 힙에 추가한다.

따라서 아래 사진처럼 변해있다.

![dijkstra_2.png](/assets/images/algorithm/dijkstra_2.png)

최소힙에서 비용이 제일 적은 정점을 꺼내온다. 2번 정점이 비용 2로 제일 적기 때문에 2번에 연결된 다른 간선들을 탐색하게 된다.

3번 정점밖에 연결되어 있지 않은데, **<span class="orange">2번 정점의 비용 + 간선의 비용</span>이 3번 정점의 비용보다 크기 때문에**,<br/>
1번 정점에서 3번 정점까지 가는데에 드는 **최소 비용을 갱신하지 않는다**. 

![dijkstra_3.png](/assets/images/algorithm/dijkstra_3.png)

그림에서 보이듯이 1->2->3으로 갈 때 드는 비용보다 1->3으로 갈 때 드는 비용이 더 적다.

그 다음에 최소힙에서 뽑힌 원소는 3번 정점이다. 3번 정점에 연결된 간선들에 대해 탐색한다.

![dijkstra_4.png](/assets/images/algorithm/dijkstra_4.png)

**3번 정점까지 가는 비용인 3과 각 간선의 비용을 더한 값이 기존에 배열에 들어있던 무한값보다 작기 때문에** 값이 갱신된다.

값을 갱신했다면 최소힙에 넣는다. 간선을 모두 순회했다면 최소힙에 의해 제일 비용이 작은 <6번, 5> 원소가 가장 앞에 있다. 그렇기 때문에 6번 정점을 먼저 탐색하게 된다.

![dijkstra_5.png](/assets/images/algorithm/dijkstra_5.png)

6번 정점을 탐색하게 되면 5번 정점으로 가는 간선도 탐색하게 되는데, 6번 정점까지 가는 비용인 5와 간선의 비용 3을 더했지만 5번 정점까지 갈 때 드는 비용인 7보다 크다. 따라서 갱신되지 않는다.

7번 정점으로 가는 간선도 있으므로 7번 정점까지 갈 때 드는 비용인 INF가 5+4=9, 9로 바뀌게 된다. 그리고 최소힙에 추가한다.

이 상황에서 비용이 제일 작은 정점은 5번이므로 5번 정점을 탐색한다.

![dijkstra_6.png](/assets/images/algorithm/dijkstra_6.png)

4번 정점으로 가는 간선을 탐색하게 되면 기존에 11만큼의 비용을 갖고 있었지만 <span class="orange">5번 정점으로 갈 때 드는 비용인 7과 간선의 비용 3을 더하면 10이 되므로 비용이 갱신된다</span>.

이렇게 모든 정점에 대해 최소힙이 빌 때까지 작업을 반복하면 아래처럼 결과가 나온다.

![dijkstra_7.png](/assets/images/algorithm/dijkstra_7.png)

이 결과는 1번 정점에서 출발할 때 다른 정점까지의 최소 비용을 의미한다.

# 구현

최소힙은 직접 구현하지 않고 STL을 사용했다.

```cpp
const int INT = 2147483647;
using PII = pair<int, int>; // <정점, 비용>

vector<int> dijkstra(
    int start, 
    int N, 
    vector<PII> graph[]){  // 방향성을 가진 그래프, graph[start] = <end, dist>

    vector<int> dist(N, INF); // 최소 비용 배열을 무한대로 초기화
    priority_queue<PII> heap; // <도착 정점, 비용>

    dist[start] = 0;
    heap.push({start, 0});

    while(!heap.empty()){
        int currentNode = pq.top().first;
        int currentDist = -pq.top().second;
        // 음수로 하는 이유는 priority_queue가 
        // 기본적으로 최대힙을 쓰기 때문이다.
        heap.pop();

        for(auto iter = graph[currentNode].start(); 
            iter != graph[currentNode].end();
            iter++){
            int endNode = iter->first;
            int endNodeDist = currentDist + iter->second;
            if(endNodeDist < dist[endNode]){
                // 현재 정점의 최소 비용 + 간선의 비용이
                // 도착 정점의 최소 비용보다 작다면,
                // 도착 정점의 값을 갱신한다.
                // 그리고 도착 정점을 최소힙에 추가한다.
                dist[endNode] = endNodeDist;
                heap.push({endNode, endNodeDist});
            }
        }
    }

    // start로부터 그래프 내 각 정점까지 이동할 때 드는 최소 비용
    return dist;
}
```

# 정리

특정 지점에서 다른 지점까지 이동할 때 어떤 간선을 골라 최소 경로로 이동해야하는지 알아야 한다면 다익스트라가 알맞다.

만약 비용이 음수인 간선이 있다면 어쩔 수 없이 플로이드-워셜 알고리즘을 써야한다.