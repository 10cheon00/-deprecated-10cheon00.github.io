---
layout: post
categories: Algorithm
published_at: Tue Mar 21 2023 14:18:00 GMT+0900
---

# 최소 신장 트리 (크루스칼 알고리즘)

그래프 내에 있는 모든 정점들을 가장 적은 비용으로 연결을 해야할 때 쓰는 알고리즘이다.

## 시간복잡도

간선의 개수 = $$E$$

서로소 집합을 찾는 데 걸리는 시간 &#8776; $$ O(1) $$

모든 간선을 정렬 후 탐색하므로 좋은 정렬 알고리즘을 사용하면 $$ O(ElogE) $$

따라서 시간복잡도는 $$ O(1) + O(ElogE) = O(ElogE) $$이다.

# 원리

1. 먼저 전체 간선을 오름차순으로 정렬한다.
2. 정렬된 간선을 위에서부터 하나씩 꺼내면서 트리를 만든다.
    만약 추가하려는 간선이 <span class="red">**사이클**</span>을 만들게 된다면 추가하지 않는다.

사이클은 아래 사진처럼 그래프가 순환하는 구조를 말한다.

![kruskal_1.png](/assets/images/algorithm/kruskal_1.png)

사이클을 판별하는 방법은 **[서로소 집합](/algorithm/서로소-집합)**이라는 개념을 알고 있어야 한다.

서로소 집합을 이용해, <span class="orange">간선의 양 정점이 같은 집합에 속해있다면 사이클을 생성함</span>을 의미한다.

# 설명

아래 사진과 같은 그래프가 있다고 하자.

![kruskal_2.png](/assets/images/algorithm/kruskal_2.png)

전체 간선을 정렬하는 것과 서로소 집합은 사진에 넣기 버거워서 따로 넣지 않았다.

전체 간선이 비용을 기준으로 오름차순 정렬되었다고 하자. 현재 최소 비용인 간선은 2번 정점에서 3번 정점로 가는 간선이다.

그러므로 2번과 3번 정점를 선택해 연결한다. 

![kruskal_3.png](/assets/images/algorithm/kruskal_3.png)

그 다음으로 비용이 적은 간선들을 계속 선택해 트리를 구성한다.

3번에서 6번으로 가는 간선이 제일 적은 비용을 가지므로 6번 정점을 3번 정점에 연결한다.
 
![kruskal_4.png](/assets/images/algorithm/kruskal_4.png)

미리 구성된 트리에 정점을 추가한다는 의미는 <span class="green">서로소 집합에서 트리의 루트 인덱스를 저장한다</span>는 말과 같다.

현재 시점에서 서로소 집합은 이렇게 구성되어 있을 것이다.

```
 index|  2|  3|  6
------+---+---+---
parent|  2|  2|  .
```

따라서 6번 정점에 연결할 <span class="orange">트리의 루트 인덱스는 2</span>이므로 서로소 집합에 있는 <span class="orange">6번 인덱스의 parent는 2가 된다</span>.

```
 index|  2|  3|  6
------+---+---+---
parent|  2|  2|  2
                 ^--- 6번 정점이 연결될 3번 정점에 저장된 루트 인덱스를 복사
```

다음으로 비용이 적은 간선은 7번에서 8번으로 가는 간선이다.

![kruskal_5.png](/assets/images/algorithm/kruskal_5.png)

그 다음으로 비용이 적은 간선은 1번에서 4번으로 가는 간선이다.

![kruskal_6.png](/assets/images/algorithm/kruskal_6.png)

그 다음으로 비용이 적은 간선은 2번에서 4번으로 가는 간선이다.

![kruskal_7.png](/assets/images/algorithm/kruskal_7.png)

정점을 연결하기 전에 서로소 집합은 다음과 같이 구성되어 있다.

```
 index|  1|  2|  3|  4|  6|  7|  8
------+---+---+---+---+---+---+---
parent|  1|  2|  2|  1|  2|  7|  7
```

이제 2번과 4번을 잇는다면 두 개의 트리가 하나로 합쳐지는 것이기 때문에 **<span class="orange">두 트리중 어느 한 트리의 루트 인덱스는 다른 트리의 루트를 갖게 된다</span>**.

```
 index|  1|  2|  3|  4|  6|  7|  8
------+---+---+---+---+---+---+---
parent|  1|  1|  2|  1|  2|  7|  7
             ^
             `--- 트리의 루트는 자기 자신을 가져야 했지만 
            두 트리가 하나로 합쳐지므로 한 트리의 루트는
            자기 자신을 가지지 않고 다른 트리의 루트를 가지게 됨
```

이렇게 했을 때 3, 6번 정점의 루트를 찾으려고 하면, `parent[6] -> 2, parent[2] -> 1, parent[1] -> 1`로 이어지게 되어 1번 정점이 루트임을 알게 된다.

정점을 트리에 연결했으니 계속해서 비용이 적은 간선을 찾아 연결한다.

다음으로 비용이 적은 간선은 3번에서 5번으로 가는 간선이다.

![kruskal_8.png](/assets/images/algorithm/kruskal_8.png)

다음으로 비용이 적은 간선은 5번에서 7번으로 가는 간선이다.

이 때도 마찬가지로 두 트리를 하나로 합치는 과정이기 때문에, 7번 정점(루트)의 인덱스가 1번 정점(루트)으로 저장된다.

```
 index|  1|  2|  3|  4|  5|  6|  7|  8
------+---+---+---+---+---+---+---+---
parent|  1|  1|  2|  1|  1|  2|  7|  7

after unionParent(5, 7),

 index|  1|  2|  3|  4|  5|  6|  7|  8
------+---+---+---+---+---+---+---+---
parent|  1|  1|  2|  1|  1|  2|  1|  7
                                 ^
다른 트리의 루트 인덱스를 갖게 됨--`
```

![kruskal_9.png](/assets/images/algorithm/kruskal_9.png)

다음으로 비용이 적은 간선을 찾아 연결한다. 

1번에서 2번으로 가는 간선이 비용 4로 제일 적으나, 이는 <span class="red">사이클을 발생시키기 때문에 추가하지 않는다</span>.

바로 위에 있는 서로소 집합 배열을 이용해 확인할 수 있다.

`parent[1]`과 `parent[2]`를 비교했을 때 **<span class="orange">두 정점의 루트가 같다면 이미 같은 집합에 속해있다는 말이다</span>**.

사이클을 발생시키는 간선들을 모두 건너뛰면 최소비용트리가 완성된다.

![kruskal_10.png](/assets/images/algorithm/kruskal_10.png)


# 구현

```c++
struct Node{
    int start, end, dist;
};
Node edges[MAX_EDGE];

// 서로소 집합
int parent[MAX_VERTEX + 1];

// 정점의 부모를 찾기
// 해당 정점의 부모가 최상위 부모로 되어있지 않다면
// 재귀식을 통해 최상위 부모를 저장한다.
int findParent(int x){
    if(parent[x] != x){
        parent[x] = findParent(parent[x]);
    }
    return parent[x];
}

// 합집합 연산
void unionParent(int x, int y){
    x = findParent(x);
    y = findParent(y);
    if(x != y){
        // x의 부모를 y의 부모로 설정하여
        // 두 집합을 합친다.
        parent[x] = y;
    }
}

int V, E; // 정점, 간선

void init(){
    // union-find를 사용하기 위해 
    // 모든 정점이 자기 자신을 부모로 갖도록하여
    // 개별 집합으로 나타낸다.
    for(int i=1; i<= V; i++){
        parent[i] = i;
    }

    // 간선을 정렬한다.
    sort(edges.begin(), edges.end());
}

int kruskal(){
    int minDist = 0;
    init();

    for(int i=0; i < E; i++){
        // 트리에 간선을 추가할 때 사이클이 구성되는지 알려면
        // 간선의 시작 정점이 속한 집합과 도착 정점이 속한 집합이
        // 같은 집합일 때 사이클이 구성된다.
        if(findParent(edges[i].start) != findParent(edges[i].end)){
            minDist += edges[i].dist;
            unionParent(edges[i].start, edges[i].end);
        }
    }
    
    return minDist;
}
```

# 정리

비슷한 알고리즘으로 프림 알고리즘이 있다. 

크루스칼 알고리즘은 전체 간선을 정렬한 후 탐색하기 때문에 트리가 여러 개 만들어질 수 있지만, 프림 알고리즘은 선택한 정점들이 가진 간선만 탐색하기 때문에 1개의 트리에 계속 정점을 연결해간다.